-- Edit mode -*- lua -*-

define_mode("edit")

-- most of the functions these are bound to should be self-explanatory
-- just by looking at the function name.

local exit = function()
   ship.editor.save()
   ship.editor.change_buffer(nil) -- nil buffer means flight mode
end

bind("edit", "escape", exit)
bind("edit", "ctrl-return", exit)

bind("edit", "ctrl-q", function()
        ship.editor.save()
        ship.ui.quit()
end)

-- cycle forwards and backwards through open buffers.
bind("edit", "ctrl-pageup", lume.fn(ship.editor.next_buffer, -1))
bind("edit", "ctrl-pagedown", ship.editor.next_buffer)

-- not all keyboards have these keys, but they're handy.
bind("edit", "appback", lume.fn(ship.editor.next_buffer, -1))
bind("edit", "appforward", ship.editor.next_buffer)

-- switch buffer by name.
bind("edit", "alt-x", function()
        local last_buffer = ship.editor.last_buffer()
        last_buffer = last_buffer and last_buffer.path or "*console*"
        local callback = function(b)
           ship.editor.change_buffer(b ~= "" and b or last_buffer)
        end
        ship:read_line("Switch to buffer (default: " ..last_buffer.. "): ",
                       callback)
end)

-- you can bind return to just ship.editor.newline to disable auto-indent.
bind("edit", "return", ship.editor.newline_and_indent)
bind("edit", "ctrl-z", ship.editor.undo)
bind("edit", "ctrl-s", ship.editor.save)
bind("edit", "alt-r", ship.editor.revert)

-- "Conventional" keys
bind("edit", "backspace", ship.editor.delete_backwards)
bind("edit", "delete", ship.editor.delete_forwards)

bind("edit", "home", ship.editor.beginning_of_line)
bind("edit", "end", ship.editor.end_of_line)
bind("edit", "left", ship.editor.backward_char)
bind("edit", "right", ship.editor.forward_char)
bind("edit", "up", ship.editor.prev_line)
bind("edit", "down", ship.editor.next_line)
bind("edit", "wheelup", ship.editor.prev_line)
bind("edit", "wheeldown", ship.editor.next_line)

bind("edit", "ctrl- ", ship.editor.mark)
bind("edit", "ctrl-space", ship.editor.mark)
bind("edit", "ctrl-c", ship.editor.kill_ring_save)
bind("edit", "ctrl-x", ship.editor.kill_region)
bind("edit", "ctrl-v", ship.editor.yank)

bind("edit", "alt-v", ship.editor.system_yank)
bind("edit", "alt-c", ship.editor.system_copy_region)

bind("edit", "pageup", ship.editor.scroll_up)
bind("edit", "pagedown", ship.editor.scroll_down)

-- insert a page-break, rendered as a horizontal line.
bind("edit", "ctrl-l", function()
        ship.editor.newline()
        ship.editor.textinput("\f")
        ship.editor.newline()
end)

-- Search
bind("edit", "alt-s", function()
        local b = ship.editor.current_buffer()
        local old_point, old_point_line, old_mark, old_mark_line =
           b.point, b.point_line, b.mark, b.mark_line
        local last_line = b.mark_line
        local callback = function(s)
           if(s == "") then return end
           local search = function(l, n)
              if(n ~= last_line) then b.mark = 0 end
              local start, finish = utf8.find(l, s, b.mark)
              if(start) then
                 b.point_line = n
                 b.point = start - 1
                 b.mark_line = n
                 b.mark = finish
                 last_line = n
              end
              return start
           end
           for line = b.point_line, #b.lines do
              if(search(b.lines[line], line)) then
                 return
              end
           end
           -- No matches, restore point and mark
           b.point, b.point_line, b,mark, b.mark_line =
              old_point, old_point_line, old_mark, old_mark_line
        end
        ship:read_line("Search: ", callback)
end)

-- Search and replace
-- FIXME: there is a lot of code in common between this and the regular search
-- function. See if it is reasonable to factor out some common functionality.
bind("edit", "alt-r", function()
        local b = ship.editor.current_buffer()
        local old_point, old_point_line, old_mark, old_mark_line =
           b.point, b.point_line, b.mark, b.mark_line
        local last_line = b.mark_line
        local callback_s = function(s)
           local callback_r = function(r)
              if(s == "") then return end
              local replace = function(l, n)
                 if(n ~= last_line) then b.mark = 0 end
                 local new_line = utf8.gsub(l, s, r, 1)
                 if(new_line == l) then
                    return false
                 else
                    b.lines[n] = new_line
                    return true
                 end
              end
              for line = b.point_line, #b.lines do
                 if(replace(b.lines[line], line)) then
                    return
                 end
              end
              -- No matches, restore point and mark
              b.point, b.point_line, b,mark, b.mark_line =
                 old_point, old_point_line, old_mark, old_mark_line
           end
           ship:read_line("Replace '" .. s .. "' with: ", callback_r)
        end
        ship:read_line("Search: ", callback_s)
end)

bind("edit", "alt-k", ship.editor.close)

-- force close even if unsaved changes exist.
bind("edit", "ctrl-alt-k", function()
        ship.editor.close(true)
end)

bind("edit", "alt-g", function()
        ship:read_line("Go to line: ", function(l)
                          ship.editor.go_to_line(tonumber(l)) end)
end)

-- comment this out to disable Emacs key bindings.
dofile("src.emacs")
